import { useState, useEffect } from "react";
import { useToast } from "@/hooks/use-toast";
import { MenuCategory, MenuItem, Location, Table, MenuItemVariant } from "@/types/models";
import { supabase } from "@/integrations/supabase/client";

export const usePublicMenu = (locationId: string, tableId: string) => {
  const [location, setLocation] = useState<Location | null>(null);
  const [table, setTable] = useState<Table | null>(null);
  const [categories, setCategories] = useState<MenuCategory[]>([]);
  const [menuItems, setMenuItems] = useState<MenuItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const { toast } = useToast();
  const [allLocations, setAllLocations] = useState<any[]>([]);

  // Add cache-busting mechanism
  useEffect(() => {
    // Add meta tags to prevent caching
    const addNoCacheMetaTags = () => {
      const metaTags = [
        { name: 'cache-control', content: 'no-cache, no-store, must-revalidate' },
        { name: 'pragma', content: 'no-cache' },
        { name: 'expires', content: '0' }
      ];

      metaTags.forEach(tag => {
        let meta = document.querySelector(`meta[name="${tag.name}"]`);
        if (!meta) {
          meta = document.createElement('meta');
          meta.setAttribute('name', tag.name);
          document.head.appendChild(meta);
        }
        meta.setAttribute('content', tag.content);
      });
    };

    addNoCacheMetaTags();
  }, []);

  // Real-time –ø—ñ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∑–º—ñ–Ω–∏ –≤ menu_items –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó –º—ñ–∂ –ø—Ä–∏—Å—Ç—Ä–æ—è–º–∏
  useEffect(() => {
    if (!location?.cafeId) return;

    console.log('üì° PUBLIC MENU: Setting up real-time subscription for cafe:', location.cafeId);
    
    // –ü—ñ–¥–ø–∏—Å—É—î–º–æ—Å—è –Ω–∞ –∑–º—ñ–Ω–∏ –≤ —Ç–∞–±–ª–∏—Ü—ñ menu_items –¥–ª—è —Ü—å–æ–≥–æ –∫–∞—Ñ–µ
    const channel = supabase
      .channel('menu-items-changes')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'menu_items',
          filter: `cafe_id=eq.${location.cafeId}`
        },
        (payload) => {
          console.log('üì° PUBLIC MENU: Real-time update received:', payload);
          
          // –û–Ω–æ–≤–ª—é—î–º–æ –ª–æ–∫–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω –∑ –Ω–æ–≤–∏–º–∏ –¥–∞–Ω–∏–º–∏
          setMenuItems(prevItems => {
            const updatedItems = [...prevItems];
            const itemIndex = updatedItems.findIndex(item => item.id === payload.new.id);
            
            if (itemIndex >= 0) {
                             // –û–Ω–æ–≤–ª—é—î–º–æ —ñ—Å–Ω—É—é—á–∏–π —Ç–æ–≤–∞—Ä
              updatedItems[itemIndex] = {
                ...updatedItems[itemIndex],
                order: payload.new.order !== undefined ? payload.new.order : updatedItems[itemIndex].order || 0
              };
              
              console.log('üì¶ PUBLIC MENU: Updated item order:', {
                id: payload.new.id,
                name: updatedItems[itemIndex].name,
                newOrder: payload.new.order
              });
              
              // –ü–µ—Ä–µ—Å–æ—Ä—Ç–æ–≤—É—î–º–æ —Ç–æ–≤–∞—Ä–∏ –≤ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó
              const categoryId = updatedItems[itemIndex].categoryId;
              const categoryItems = updatedItems.filter(item => item.categoryId === categoryId);
              const otherItems = updatedItems.filter(item => item.categoryId !== categoryId);
              
              categoryItems.sort((a, b) => (a.order || 0) - (b.order || 0));
              
              return [...otherItems, ...categoryItems];
            }
            
            return prevItems;
          });
        }
      )
      .subscribe();

    return () => {
      console.log('üì° PUBLIC MENU: Cleaning up real-time subscription');
      supabase.removeChannel(channel);
    };
  }, [location?.cafeId]);

  // –°–ª—É—Ö–∞—á –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ—Ä—è–¥–∫—É —Ç–æ–≤–∞—Ä—ñ–≤ –ø—Ä–∏ –∑–º—ñ–Ω—ñ localStorage (fallback –¥–ª—è same-tab updates)
  useEffect(() => {
    const handleStorageChange = (event: StorageEvent) => {
      if (event.key && event.key.startsWith('menuItemOrder_')) {
        console.log('üì° PUBLIC MENU: localStorage change detected (fallback):', event.key);
        // –¶–µ–π –∫–æ–¥ –∑–∞–ª–∏—à–∞—î–º–æ —è–∫ fallback –¥–ª—è same-tab —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó
        if (location?.cafeId) {
          setMenuItems(prevItems => {
            const categoryId = event.key!.replace('menuItemOrder_', '');
            const savedOrderRaw = event.newValue;
            
            if (savedOrderRaw) {
              try {
                const savedOrder = JSON.parse(savedOrderRaw) as Record<string, number>;
                console.log(`üìÇ PUBLIC MENU: Applying localStorage order for category ${categoryId}:`, savedOrder);
                
                // –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –Ω–æ–≤–∏–π –ø–æ—Ä—è–¥–æ–∫ –¥–æ —Ç–æ–≤–∞—Ä—ñ–≤
                const updatedItems = [...prevItems];
                const categoryItems = updatedItems.filter(item => item.categoryId === categoryId);
                categoryItems.sort((a, b) => {
                  const orderA = savedOrder[a.id] ?? 999;
                  const orderB = savedOrder[b.id] ?? 999;
                  return orderA - orderB;
                });
                
                // –ó–∞–º—ñ–Ω—é—î–º–æ —Ç–æ–≤–∞—Ä–∏ —Ü—ñ—î—ó –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó –≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω–∏–º–∏
                return updatedItems.filter(item => item.categoryId !== categoryId).concat(categoryItems);
              } catch (e) {
                console.log(`‚ö†Ô∏è PUBLIC MENU: Could not parse localStorage order for category ${categoryId}`);
              }
            }
            
            return prevItems;
          });
        }
      }
    };

    // –î–æ–¥–∞—î–º–æ —Å–ª—É—Ö–∞—á –¥–ª—è –∑–º—ñ–Ω–∏ localStorage
    window.addEventListener('storage', handleStorageChange);
    
    // –¢–∞–∫–æ–∂ –¥–æ–¥–∞—î–º–æ —Å–ª—É—Ö–∞—á –¥–ª—è –∫–∞—Å—Ç–æ–º–Ω–∏—Ö –ø–æ–¥—ñ–π (–¥–ª—è –∑–º—ñ–Ω–∏ –≤ —Ç—ñ–π –∂–µ –≤–∫–ª–∞–¥—Ü—ñ)
    const handleCustomStorageChange = (event: CustomEvent) => {
      handleStorageChange(event.detail);
    };
    
    window.addEventListener('localStorageChange', handleCustomStorageChange as EventListener);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('localStorageChange', handleCustomStorageChange as EventListener);
    };
  }, [location?.cafeId]);

  useEffect(() => {
    const fetchMenuData = async () => {
      if (!locationId || !tableId) {
        // console.log("üîç PUBLIC MENU: Missing locationId or tableId:", { locationId, tableId });
        setIsLoading(false);
        return;
      }

      try {
        setIsLoading(true);
        setError(null);

        // console.log("üîç PUBLIC MENU: Starting fetch for location:", locationId, "tableId from URL:", tableId);
        // console.log("üîç PUBLIC MENU: Full URL:", window.location.href);

        // Remove initial fetch for all locations as it can be a performance bottleneck
        // console.log("üîç PUBLIC MENU: Checking all locations in database...");
        // const { data: allLocations, error: allLocationsError } = await supabase
        //   .from('locations')
        //   .select('*');
        
        // console.log("üîç PUBLIC MENU: All locations in database:", allLocations?.map(loc => ({
        //   id: loc.id,
        //   name: loc.name,
        //   cafe_id: loc.cafe_id
        // })));
        // if (allLocationsError) {
        //   console.error("‚ùå PUBLIC MENU: Error fetching all locations:", allLocationsError);
        // }

        // setAllLocations(allLocations || []);

        // Fetch location data with cache busting
        // console.log("üîç PUBLIC MENU: Looking for specific location:", locationId);
        // console.log("üîç PUBLIC MENU: SQL Query:", `SELECT * FROM locations WHERE id = '${locationId}'`);
        
        const cacheBreaker = new Date().getTime();
        const { data: locationData, error: locationError } = await supabase
          .from('locations')
          .select('*')
          .eq('id', locationId)
          .maybeSingle();

        // console.log("üîç PUBLIC MENU: Raw location data from database:", locationData);
        // console.log("üîç PUBLIC MENU: Location error if any:", locationError);

        if (locationError) {
          // console.error("‚ùå PUBLIC MENU: Location error:", locationError);
          throw new Error(`–ü–æ–º–∏–ª–∫–∞ –ø–æ—à—É–∫—É –ª–æ–∫–∞—Ü—ñ—ó: ${locationError.message}`);
        }

        if (!locationData) {
          // console.error("‚ùå PUBLIC MENU: Location not found for ID:", locationId);
          // console.log("üîç PUBLIC MENU: Available locations:", allLocations?.map(l => ({ 
          //   id: l.id, 
          //   name: l.name,
          //   cafe_id: l.cafe_id 
          // })));
          throw new Error(`–õ–æ–∫–∞—Ü—ñ—é –∑ ID ${locationId} –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.`);
        }

        // console.log("‚úÖ PUBLIC MENU: Location found:", locationData);
        setLocation({
          id: locationData.id,
          cafeId: locationData.cafe_id,
          name: locationData.name,
          address: locationData.address,
          createdAt: locationData.created_at
        });

        // Fetch all tables for this location
        const { data: allTables, error: allTablesError } = await supabase
          .from('tables')
          .select('id, name, location_id, qr_code, qr_code_url, created_at')
          .eq('location_id', locationId);
        
        // console.log("üîç PUBLIC MENU: All tables for location:", allTables);
        if (allTablesError) {
          // console.error("‚ùå PUBLIC MENU: Error fetching tables for location:", allTablesError);
        }

        // Find table by matching the tableId with the table ID directly
        // The tableId in URL is now the actual table ID from database
        const matchingTable = allTables?.find(table => {
          // console.log("üîç PUBLIC MENU: Comparing tableId:", tableId, "with table ID:", table.id, "for table:", table.name);
          return table.id === tableId;
        });

        // console.log("üîç PUBLIC MENU: Found matching table:", matchingTable);

        if (!matchingTable) {
          // console.error("‚ùå PUBLIC MENU: Table not found for ID:", tableId, "in location:", locationId);
          // console.log("üîç PUBLIC MENU: Available tables with their IDs:", allTables?.map(t => ({ 
          //   name: t.name, 
          //   id: t.id,
          //   qr_code_url: t.qr_code_url
          // })));
          throw new Error(`Table not found. The QR code may be outdated or damaged.`);
        }

        // console.log("‚úÖ PUBLIC MENU: Table found:", matchingTable);
        setTable({
          id: matchingTable.id,
          locationId: matchingTable.location_id,
          name: matchingTable.name,
          qrCode: matchingTable.qr_code,
          qrCodeUrl: matchingTable.qr_code_url,
          createdAt: matchingTable.created_at
        });

        // Fetch menu categories for this cafe with cache busting
        const { data: categoriesData, error: categoriesError } = await supabase
          .from('menu_categories')
          .select('*')
          .eq('cafe_id', locationData.cafe_id)
          .order('order');

        if (categoriesError) {
          // console.error("‚ùå PUBLIC MENU: Categories error:", categoriesError);
          throw new Error(`–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∫–∞—Ç–µ–≥–æ—Ä—ñ–π: ${categoriesError.message}`);
        }

        // console.log("‚úÖ PUBLIC MENU: Categories found:", categoriesData);
        const mappedCategories = (categoriesData || []).map(cat => ({
          id: cat.id,
          cafeId: cat.cafe_id,
          name: cat.name,
          order: cat.order,
          createdAt: cat.created_at
        }));
        setCategories(mappedCategories);

        // Fetch all menu items for these categories
        if (mappedCategories.length > 0) {
          const categoryIds = mappedCategories.map(cat => cat.id);
          
          // –°–ø–æ—á–∞—Ç–∫—É —Å–ø—Ä–æ–±—É—î–º–æ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è–º –∑–∞ order (–∑ cache busting)
          let { data: itemsData, error: itemsError } = await supabase
            .from('menu_items')
            .select('*')
            .in('category_id', categoryIds)
            .order('order');
          
          // –Ø–∫—â–æ –ø–æ–º–∏–ª–∫–∞ —á–µ—Ä–µ–∑ –≤—ñ–¥—Å—É—Ç–Ω—ñ—Å—Ç—å –ø–æ–ª—è order, –∑–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –±–µ–∑ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è
          if (itemsError && itemsError.message.includes('column "order" does not exist')) {
            console.log('‚ö†Ô∏è PUBLIC MENU: Order column does not exist, loading without order');
            const fallbackResult = await supabase
              .from('menu_items')
              .select('*')
              .in('category_id', categoryIds)
              .order('created_at');
            
            itemsData = fallbackResult.data;
            itemsError = fallbackResult.error;
          }

          if (itemsError) {
            // console.error("‚ùå PUBLIC MENU: Items error:", itemsError);
            throw new Error(`–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Å—Ç—Ä–∞–≤: ${itemsError.message}`);
          }

          // console.log("‚úÖ PUBLIC MENU: Items found:", itemsData);
          const mappedItems = (itemsData || []).map(item => ({
            id: item.id,
            categoryId: item.category_id,
            name: item.name,
            description: item.description || undefined,
            price: typeof item.price === 'string' ? parseFloat(item.price) : item.price,
            weight: item.weight || undefined,
            imageUrl: item.image_url || undefined,
            variants: item.variants ? (Array.isArray(item.variants) ? item.variants as MenuItemVariant[] : undefined) : undefined,
            order: item.order || 0,
            createdAt: item.created_at
          }));
          
          console.log('üì¶ PUBLIC MENU: Loaded items with order from database:', 
            mappedItems.map(item => ({ name: item.name, order: item.order, categoryId: item.categoryId }))
          );
          
          setMenuItems(mappedItems);
        } else {
          // console.log("üîç PUBLIC MENU: No categories found, setting empty menu items");
          setMenuItems([]);
        }
      } catch (err) {
        // console.error("‚ùå PUBLIC MENU: Error fetching data:", err);
        const error = err instanceof Error ? err : new Error('–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞');
        setError(error);
        toast({
          variant: "destructive",
          title: "–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –º–µ–Ω—é",
          description: error.message
        });
      } finally {
        setIsLoading(false);
      }
    };

    fetchMenuData();
  }, [locationId, tableId, toast]);

  return {
    location,
    table,
    categories,
    menuItems,
    isLoading,
    error,
    allLocations
  };
};
